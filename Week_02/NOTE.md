> # 学习笔记

> ## HashMap小结

> * get分析

```
 294:   public V get(Object key)
 295:   {
 296:     int idx = hash(key);
 297:     HashEntry<K, V> e = buckets[idx];
 298:     while (e != null)
 299:       {
 300:         if (equals(key, e.key))
 301:           return e.value;
 302:         e = e.next;
 303:       }
 304:     return null;
 305:   }
 ```
 
 > 首先对key求出哈希值，根据hash值求出在桶中的位置，每个桶的位置维护一条链表，
 遍历这条链表找到key所对应的值。如果找不到，返回null。由于值也有可能是null，因此不能根据
 返回值是否为null来判断该key是否存在。
 
 > * put分析
 
 ```
  public V put(K key, V value)
	...
	...
	...
```

> 对key求出hash值，在桶中找对应的位置。如果找到的位置对应元素非空，遍历该位置维护的链表，
如果找到对应的值，用新值替换掉老的值，并且返回老的值。

>  如果没找到旧值，元素个数加1，判断是否需要扩大桶的大小，如果需要，对桶大小进行调整。根据key的hash值插入一个新的元素，返回null。

> * 时间复杂度

> 平均情况下，查找、插入、删除的时间复杂度都是O(1); 

> 最坏情况下，查找、插入、删除的时间复杂度都是O(n).


## 哈希表、映射、集合

映射与集合在大部分程序语言中都是作为基础的数据结构，例如java中是Map，Set以及各种子类。

在C++中是map,set,unordered_map,unordered_set。

在python中是dict, set。

底层实现通常都是红黑树与哈希表。红黑树实现时元素是有序的，哈希表实现时是无序的，哈希表
实现时通常效率更好。哈希表的效率取决与散列函数与桶的大小。哈希表实现在大多数情况下都有较好的性能。


## 树、二叉树、二叉搜索树

树通常用递归的方式进行解答，递归的优点是简洁明了。有部分可以采用循环迭代的方式来实现，
可以通过记忆数组来保存中间结果，避免重复计算问题。

## 堆和二叉堆

堆的实现有很多种，包括二叉堆，斐波那契堆；二叉堆实现比较简单，但性能相对来说比较差。
斐波那契数列在工程中实现性能较好，相对比较复杂。

## 映射、map的应用

两数之和。

字母异位词分组。

矩阵置零。

## 队列、优先队列应用

合并k个排序链表。

滑动窗口的最大值。

## 数组、指针应用

颜色分类

## 栈的应用

柱状图中最大矩阵

## 树的应用

二叉树的中序遍历。可以递归方式。

二叉树的最大深度。可以递归方式；可以循环迭代方式。在其他题目中都采用树最大深度的方式。例如二叉树的直径。

二叉树的最小深度。跟二叉树的最大深度类似。



	